
// Преобразования типов

console.log(10 + " Hello"); // => "10 Hello"
console.log("10" + "29"); // => "1029"
console.log("7" * "3"); // => 21. Обе строки преобразуются в числа
let n = 1 - "x";
console.log(n); // => NaN. Строка "x" не может быть преобразованна в число
console.log(n + " object"); // => "NaN object". NaN преобразуется в строку "NaN"

// Явные преобразования
Number("3"); // => 3
String(false); // => "false"
false.toString(); // => "false"
Boolean([]); // => true

console.log(String(false));
//console.log(String(sfareafk)); // Ошибка

// Не явные преобразования

// Если одним операндом операции + является строка, то другой операнд преобразуется в строку
// x + "";

// Унарная операция + преобразует свой операнд в число
// +x;
//console.log(+x); // Ошибка
console.log(+"345"); // => 345 теперь число

console.log("34" - 4); // "34" преобразуется в число
console.log("34" + 4); // 4 преобразуется в строку


// parseInt
console.log(parseInt("2 erds 4 re")); // => 2

// ДЕСТРУКТУРИРУЮЩЕЕ ПРИСВАИВАНИЕ

// При деструктурирующем присваивании значение с правой строны знака равенства является массивом
// или объектом("структурированное значение"). А с левой стороны указывается одна или 
// большее количество имен переменных с применением синтаксиса, который имитирует литеральный
// синтаксис массивов или объектов

let [d1, d2] = [1, 6];
console.log(d2);
let d3 = 45,
    d4 = 20;
[d3, d4] = [d3 + 1, d4 + 3];
console.log(d4);
[d5, d6] = [33, 21];
console.log(d6);
// меняем местами значения переменных с помощью деструктуризации
[d5, d6] = [d6, d5];
console.log("d6 = " + d6);
// Облегчение работы с функциями, которые возвращают массивы значений
function toPolar(x, y) {
    return [Math.sqrt(x*x+y*y), Math.atan2(x, y)];
}
let [d7, d8] = toPolar(3, 6);
console.log(d7);
console.log(d8);

// Код, который проходит в цикле по парам имя/значение всех свойств объекта и применяет деструкту-
// рирующее присваение для преобразования таких пар из двух элементных массивов в отдельные переменные

let obj = {x: 1, y: 2};
const massObj = Object.entries(obj);
console.log(massObj);
for(const [name, value] of Object.entries(obj)) {
    console.log(name, value);
}
//  Object.entries(obj) - это метод, который используется для получения массива, содержащего 
// пары ключ-значение из указанного объекта obj в виде двухэлементных массивов.

// Количество переменных с лева и значений справа не обязательно должны совпадать
let [d9, d10] = [34];
console.log(d9); // => 34
console.log(d10); // => undefined
//
[d11, d12] = [1, 23, 54]; // лишнее с правой стороны просто игнорируется
console.log(d11); // => 1
console.log(d12); // => 23
//
[, d13, , d14] = [32, 88, 43, 57];
console.log(d13); // => 88
console.log(d14); // => 57
// Если значений больше чем переменных, но нужно собрать все значения в одну единственную переменную,
// то можно использовать ... перед последней переменной
let [d15, ...d16] = [123, 31, 7, 98, 0];
console.log(d16);
console.log(d16[2]);
console.log(d16.length);
// Вложенные массивы
let [d17, [d18, d19]] = [1, [3, 3.2], 43];
// С правой стороны не обязательно должен быть массив
// Можно использовать любой объект
let [d20, ...d21] = "Hello";
console.log(d20); // => H
console.log(d21); // => ['e', 'l', 'l', 'o']
// Когда с права указано объектное значение
let transparent = {r: 0.0, g: 0.0, b: 0.0, a:1.0};
// левая часть такого выражения должна выглядеть, тоже как объектный литерал
let {r, g, b} = transparent;
console.log(r);

